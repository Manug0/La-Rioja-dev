pipeline {
    agent any
    environment {
        SFDX_AUTH_URL = credentials('SFDX_AUTH_URL_PRE')
        SFDX_ALIAS = 'pre'
        SF_CMD = 'C:\\Users\\Manu\\AppData\\Local\\sf\\client\\2.92.7-df40848\\bin\\sf.cmd'
        GITHUB_TOKEN = credentials('github-pat')
    }
    
    stages {
        stage('Inicializar Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Iniciando deploy a producciÃ³n...', 'production-deploy')
                    
                    echo "ğŸš€ Iniciando pipeline de deploy a producciÃ³n"
                    echo "Branch: ${env.BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT?.take(8)}"
                }
            }
        }
        
        stage('Verificar SFDX') { 
            steps { 
                script {
                    updateGitHubStatus('pending', 'Verificando herramientas...', 'production-deploy')
                    
                    echo "ğŸ”§ Verificando SFDX CLI..."
                    bat "${SF_CMD} --version"
                    echo "âœ… SFDX CLI verificado"
                }
            }
        }
        
        stage('Authenticate') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Autenticando con producciÃ³n...', 'production-deploy')
                    
                    echo "ğŸ” Autenticando con org de producciÃ³n..."
                    bat 'echo %SFDX_AUTH_URL% > auth_url.txt'
                    bat "${SF_CMD} org login sfdx-url --sfdx-url-file auth_url.txt --alias %SFDX_ALIAS%"
                    echo "âœ… AutenticaciÃ³n exitosa"
                }
            }
        }
        
        stage('Generar Package Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Preparando package para deploy...', 'production-deploy')
                    
                    echo "ğŸ“¦ Generando package para deploy..."
                    
                    // Crear directorio package si no existe
                    bat "if not exist package mkdir package"
                    
                    try {
                        // Intentar obtener los cambios del Ãºltimo merge
                        def lastMergeCommit = bat(script: "git log --merges -1 --pretty=format:%%H", returnStdout: true).trim()
                        def parentCommits = bat(script: "git log --pretty=format:%%P -1 ${lastMergeCommit}", returnStdout: true).trim().split(' ')
                        
                        if (parentCommits.length >= 2) {
                            def fromCommit = parentCommits[0]  // Commit de main antes del merge
                            def toCommit = parentCommits[1]    // Ãšltimo commit de la rama mergeada
                            
                            echo "ğŸ”„ Generando delta desde ${fromCommit} hasta ${toCommit}"
                            
                            // Verificar plugin sfdx-git-delta
                            def pluginCheck = bat(script: "${SF_CMD} plugins | findstr sfdx-git-delta", returnStatus: true)
                            
                            if (pluginCheck == 0) {
                                bat "\"${SF_CMD}\" sgd source delta --from \"${fromCommit}\" --to \"${toCommit}\" --output ."
                                echo "âœ… Package.xml generado con delta"
                            } else {
                                echo "âš ï¸ Plugin sfdx-git-delta no encontrado, usando package completo"
                            }
                        } else {
                            echo "âš ï¸ No se pudo determinar el delta, usando package completo"
                        }
                        
                    } catch (Exception e) {
                        echo "âš ï¸ Error generando delta: ${e.getMessage()}"
                        echo "ğŸ”„ Usando package completo como fallback"
                    }
                    
                    // Verificar que el package.xml existe
                    if (fileExists('package\\package.xml')) {
                        echo "ğŸ“„ Contenido del package.xml:"
                        bat "type package\\package.xml"
                        echo "âœ… Package.xml listo para deploy"
                    } else {
                        updateGitHubStatus('failure', 'Error preparando package - Deploy cancelado', 'production-deploy')
                        error("âŒ Error: package.xml no encontrado")
                    }
                }
            }
        }
        
        stage('Deploy a ProducciÃ³n') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Ejecutando deploy en producciÃ³n...', 'production-deploy')
                    echo "ğŸš€ Iniciando deploy a producciÃ³n..."
                    
                    try {
                        if (env.DEPLOY_TYPE == 'DEPLOY_CON_TESTS') {
                            echo "ğŸ§ª Deploy con tests completos..."
                            bat "${SF_CMD} project deploy start --package package\\package.xml --target-org %SFDX_ALIAS% --wait 30 --test-level RunLocalTests"
                        } else {
                            echo "ğŸš€ Deploy normal (sin tests adicionales)..."
                            bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --wait 30"
                        }
                        
                        echo "âœ… Deploy completado exitosamente"
                        
                    } catch (Exception e) {
                        echo "âŒ Error en deploy: ${e.getMessage()}"
                        updateGitHubStatus('failure', 'Deploy fallÃ³ en Salesforce', 'production-deploy')
                        throw e
                    }
                }
            }
        }
        
        stage('Smoke Tests Post-Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Ejecutando tests post-deploy...', 'production-deploy')
                    
                    echo "ğŸ§ª Ejecutando smoke tests post-deploy..."
                    
                    try {
                        bat "${SF_CMD} data query --query \"SELECT Id, Name FROM User LIMIT 1\" --target-org %SFDX_ALIAS%"
                        
                        echo "âœ… Smoke tests pasaron - Org responde correctamente"
                        env.SMOKE_TESTS_PASSED = "true"
                        
                    } catch (Exception e) {
                        echo "âŒ Smoke tests fallaron: ${e.getMessage()}"
                        env.SMOKE_TESTS_PASSED = "false"
                        updateGitHubStatus('failure', 'Smoke tests fallaron - Deploy marcado como fallido', 'production-deploy')
                        error("Smoke tests post-deploy fallaron - Deploy marcado como fallido")
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                bat "if exist auth_url.txt del auth_url.txt"
                echo "ğŸ§¹ Archivos temporales limpiados"
            }
        }
        success { 
            script {
                // Solo marcar como exitoso si TODAS las verificaciones pasaron
                if (env.DEPLOY_VERIFIED == "true" && env.SMOKE_TESTS_PASSED == "true") {
                    // âœ… Ã‰XITO COMPLETO - Notificar a GitHub
                    updateGitHubStatus('success', 'Deploy completado exitosamente en producciÃ³n', 'production-deploy')
                    
                    echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘               ğŸ‰ DEPLOY A PRODUCCIÃ“N EXITOSO                 â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Branch: ${env.BRANCH_NAME}                                   â•‘
â•‘ Commit: ${env.GIT_COMMIT?.take(8)}                           â•‘
â•‘ Fecha: ${new Date()}                                         â•‘
â•‘ Tipo de Deploy: ${env.DEPLOY_TYPE}                           â•‘
â•‘                                                              â•‘
â•‘ âœ… ESTADO: CÃ³digo desplegado exitosamente en producciÃ³n     â•‘
â•‘ âœ… VERIFICACIÃ“N: Deploy confirmado como exitoso             â•‘
â•‘ âœ… SMOKE TESTS: Org funcionando correctamente               â•‘
â•‘ âœ… GITHUB: Status actualizado como SUCCESS                  â•‘
â•‘                                                              â•‘
â•‘ ğŸŒŸ Main branch ahora marcada como exitosa en GitHub         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                    
                    // Marcar el build como exitoso con descripciÃ³n
                    currentBuild.description = "ğŸ‰ Deploy exitoso y verificado - GitHub actualizado"
                    currentBuild.result = 'SUCCESS'
                    
                } else {
                    echo "âŒ Deploy no puede marcarse como exitoso - Verificaciones fallaron"
                    echo "Deploy Verified: ${env.DEPLOY_VERIFIED}"
                    echo "Smoke Tests: ${env.SMOKE_TESTS_PASSED}"
                    
                    updateGitHubStatus('failure', 'Deploy incompleto - Verificaciones fallaron', 'production-deploy')
                    currentBuild.result = 'FAILURE'
                    error("Deploy no puede considerarse exitoso debido a verificaciones fallidas")
                }
            }
        }
        failure { 
            script {
                // âŒ FALLO - Notificar a GitHub
                updateGitHubStatus('failure', 'Deploy fallÃ³ - Revisar logs de Jenkins', 'production-deploy')
                
                echo """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                ğŸ’¥ DEPLOY A PRODUCCIÃ“N FALLÃ“                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Branch: ${env.BRANCH_NAME}                                   â•‘
â•‘ Commit: ${env.GIT_COMMIT?.take(8)}                           â•‘
â•‘ Fecha: ${new Date()}                                         â•‘
â•‘ Tipo de Deploy: ${env.DEPLOY_TYPE ?: 'No especificado'}      â•‘
â•‘                                                              â•‘
â•‘ âŒ ESTADO: Deploy fallÃ³ - ProducciÃ³n NO afectada             â•‘
â•‘ âŒ GITHUB: Status marcado como FAILED                        â•‘
â•‘                                                              â•‘
â•‘ ğŸ”´ Main branch marcada como fallida hasta resoluciÃ³n         â•‘
â•‘                                                              â•‘
â•‘ Ver detalles en Jenkins para mÃ¡s informaciÃ³n                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
            }
        }
        cleanup {
            script {
                echo "ğŸ§¹ Limpieza finalizada"
            }
        }
    }
}

def updateGitHubStatus(state, description, context) {
    try {
        def repoUrl = scm.getUserRemoteConfigs()[0].getUrl()
        def repoName = repoUrl.tokenize('/').last().replace('.git', '')
        def repoOwner = repoUrl.tokenize('/')[-2]
        
        def commitSha = env.GIT_COMMIT
        def targetUrl = "${BUILD_URL}console"
        
        def payload = [
            state: state,
            target_url: targetUrl,
            description: description,
            context: "jenkins/${context}"
        ]
        
        def jsonPayload = groovy.json.JsonOutput.toJson(payload)
        
        def response = httpRequest(
            acceptType: 'APPLICATION_JSON',
            contentType: 'APPLICATION_JSON',
            httpMode: 'POST',
            requestBody: jsonPayload,
            url: "https://api.github.com/repos/${repoOwner}/${repoName}/statuses/${commitSha}",
            customHeaders: [
                [name: 'Authorization', value: 'token ' + GITHUB_TOKEN_PSW],
                [name: 'User-Agent', value: 'Jenkins-Pipeline']
            ]
        )
        
        echo "âœ… GitHub status actualizado: ${state} - ${description}"
        
    } catch (Exception e) {
        echo "âš ï¸ Error actualizando GitHub status: ${e.getMessage()}"
    }
}