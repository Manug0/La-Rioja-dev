pipeline {
    agent any
    environment {
        SFDX_AUTH_URL = credentials('SFDX_AUTH_URL_PRE')
        SFDX_ALIAS = 'pre'
        PACKAGE_DIR = 'force-app'
        SF_DISABLE_TELEMETRY = "true"
        SF_CMD = 'C:\\Users\\Manu\\AppData\\Local\\sf\\client\\2.92.7-df40848\\bin\\sf.cmd'
        // Agregar credenciales de GitHub
        GITHUB_TOKEN = credentials('github-pat')
    }
    
    // Solo ejecutar en main branch después de merge
    when {
        branch 'main'
    }
    
    stages {
        stage('Inicializar Deploy') {
            steps {
                script {
                    // Notificar GitHub que el deploy ha comenzado
                    updateGitHubStatus('pending', 'Iniciando deploy a producción...', 'production-deploy')
                    
                    echo "🚀 Iniciando pipeline de deploy a producción"
                    echo "Branch: ${env.BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT?.take(8)}"
                }
            }
        }
        
        stage('Verificar Prerequisites') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Verificando requisitos...', 'production-deploy')
                    
                    echo "🔍 Verificando prerequisites para deploy..."
                    
                    // Verificar que este commit viene de un merge de PR
                    def commitMessage = bat(script: "git log -1 --pretty=format:%%s", returnStdout: true).trim()
                    echo "📋 Commit message: ${commitMessage}"
                    
                    if (commitMessage.contains("Merge pull request")) {
                        echo "✅ Deploy autorizado - Commit proviene de merge de PR"
                        env.DEPLOY_AUTHORIZED = "true"
                    } else {
                        echo "❌ Deploy NO autorizado - Commit no proviene de merge de PR"
                        env.DEPLOY_AUTHORIZED = "false"
                        updateGitHubStatus('failure', 'Deploy cancelado - No proviene de PR validado', 'production-deploy')
                        error("Deploy cancelado: Solo se permite deploy desde merge de PR validado")
                    }
                }
            }
        }
        
        stage('Confirmación Manual') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Esperando confirmación manual...', 'production-deploy')
                    
                    echo """
╔══════════════════════════════════════════════════════════════╗
║                 🚀 CONFIRMACIÓN DE DEPLOY                    ║
╠══════════════════════════════════════════════════════════════╣
║ Entorno: PRODUCCIÓN                                         ║
║ Branch: ${env.BRANCH_NAME}                                  ║
║ Commit: ${env.GIT_COMMIT?.take(8)}                          ║
║                                                              ║
║ ⚠️  ATENCIÓN: Vas a desplegar a PRODUCCIÓN                  ║
╚══════════════════════════════════════════════════════════════╝
"""
                    
                    // Pausa para confirmación manual
                    def userInput
                    try {
                        timeout(time: 10, unit: 'MINUTES') {
                            userInput = input(
                                id: 'DeployConfirmation',
                                message: '🚀 Confirmar deploy a PRODUCCIÓN',
                                parameters: [
                                    choice(
                                        name: 'DEPLOY_ACTION',
                                        choices: ['CANCELAR', 'DEPLOY_NORMAL', 'DEPLOY_CON_TESTS'],
                                        description: 'Selecciona el tipo de deploy'
                                    )
                                ]
                            )
                        }
                    } catch (err) {
                        echo "❌ Timeout o cancelación manual del deploy"
                        updateGitHubStatus('error', 'Deploy cancelado - Timeout en confirmación manual', 'production-deploy')
                        error("Deploy cancelado por timeout o intervención manual")
                    }
                    
                    env.DEPLOY_TYPE = userInput
                    echo "✅ Tipo de deploy seleccionado: ${env.DEPLOY_TYPE}"
                    
                    if (env.DEPLOY_TYPE == 'CANCELAR') {
                        updateGitHubStatus('error', 'Deploy cancelado manualmente', 'production-deploy')
                        error("Deploy cancelado manualmente")
                    }
                    
                    updateGitHubStatus('pending', "Deploy confirmado - Tipo: ${env.DEPLOY_TYPE}", 'production-deploy')
                }
            }
        }
        
        stage('Checkout') { 
            steps { 
                checkout scm 
                echo "✅ Código descargado desde main branch"
            }
        }
        
        stage('Verificar SFDX') { 
            steps { 
                script {
                    updateGitHubStatus('pending', 'Verificando herramientas...', 'production-deploy')
                    
                    echo "🔧 Verificando SFDX CLI..."
                    bat "${SF_CMD} --version"
                    echo "✅ SFDX CLI verificado"
                }
            }
        }
        
        stage('Authenticate') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Autenticando con producción...', 'production-deploy')
                    
                    echo "🔐 Autenticando con org de producción..."
                    bat 'echo %SFDX_AUTH_URL% > auth_url.txt'
                    bat "${SF_CMD} org login sfdx-url --sfdx-url-file auth_url.txt --alias %SFDX_ALIAS%"
                    echo "✅ Autenticación exitosa"
                }
            }
        }
        
        stage('Generar Package Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Preparando package para deploy...', 'production-deploy')
                    
                    echo "📦 Generando package para deploy..."
                    
                    // Crear directorio package si no existe
                    bat "if not exist package mkdir package"
                    
                    try {
                        // Intentar obtener los cambios del último merge
                        def lastMergeCommit = bat(script: "git log --merges -1 --pretty=format:%%H", returnStdout: true).trim()
                        def parentCommits = bat(script: "git log --pretty=format:%%P -1 ${lastMergeCommit}", returnStdout: true).trim().split(' ')
                        
                        if (parentCommits.length >= 2) {
                            def fromCommit = parentCommits[0]  // Commit de main antes del merge
                            def toCommit = parentCommits[1]    // Último commit de la rama mergeada
                            
                            echo "🔄 Generando delta desde ${fromCommit} hasta ${toCommit}"
                            
                            // Verificar plugin sfdx-git-delta
                            def pluginCheck = bat(script: "${SF_CMD} plugins | findstr sfdx-git-delta", returnStatus: true)
                            
                            if (pluginCheck == 0) {
                                bat "\"${SF_CMD}\" sgd source delta --from \"${fromCommit}\" --to \"${toCommit}\" --output ."
                                echo "✅ Package.xml generado con delta"
                            } else {
                                echo "⚠️ Plugin sfdx-git-delta no encontrado, usando package completo"
                                createProductionPackage()
                            }
                        } else {
                            echo "⚠️ No se pudo determinar el delta, usando package completo"
                            createProductionPackage()
                        }
                        
                    } catch (Exception e) {
                        echo "⚠️ Error generando delta: ${e.getMessage()}"
                        echo "🔄 Usando package completo como fallback"
                        createProductionPackage()
                    }
                    
                    // Verificar que el package.xml existe
                    if (fileExists('package\\package.xml')) {
                        echo "📄 Contenido del package.xml:"
                        bat "type package\\package.xml"
                        echo "✅ Package.xml listo para deploy"
                    } else {
                        updateGitHubStatus('failure', 'Error preparando package - Deploy cancelado', 'production-deploy')
                        error("❌ Error: package.xml no encontrado")
                    }
                }
            }
        }
        
        stage('Deploy a Producción') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Ejecutando deploy en producción...', 'production-deploy')
                    
                    echo """
╔══════════════════════════════════════════════════════════════╗
║                🚀 INICIANDO DEPLOY A PRODUCCIÓN              ║
╚══════════════════════════════════════════════════════════════╝
"""
                    
                    try {
                        if (env.DEPLOY_TYPE == 'DEPLOY_CON_TESTS') {
                            echo "🧪 Deploy con tests completos..."
                            bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --wait 30 --test-level RunLocalTests"
                        } else {
                            echo "🚀 Deploy normal (sin tests adicionales)..."
                            bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --wait 30"
                        }
                        
                        echo "✅ Deploy completado exitosamente"
                        
                    } catch (Exception e) {
                        echo "❌ Error en deploy: ${e.getMessage()}"
                        updateGitHubStatus('failure', 'Deploy falló en Salesforce', 'production-deploy')
                        throw e
                    }
                }
            }
        }
        
        stage('Verificar Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Verificando resultado del deploy...', 'production-deploy')
                    
                    echo "🔍 Verificando estado del deploy..."
                    
                    try {
                        // Verificar el último deploy y obtener resultado
                        def deployResult = bat(script: "${SF_CMD} project deploy report --target-org %SFDX_ALIAS% --json", returnStdout: true).trim()
                        def deployJson = readJSON text: deployResult
                        
                        if (deployJson.result.success == true) {
                            echo "✅ Deploy verificado como exitoso"
                            env.DEPLOY_VERIFIED = "true"
                        } else {
                            echo "❌ Deploy reportado como fallido"
                            env.DEPLOY_VERIFIED = "false"
                            updateGitHubStatus('failure', 'Deploy falló en verificación final', 'production-deploy')
                            error("Deploy falló en la verificación final")
                        }
                        
                    } catch (Exception e) {
                        echo "❌ Error crítico verificando deploy: ${e.getMessage()}"
                        env.DEPLOY_VERIFIED = "false"
                        updateGitHubStatus('failure', 'Error verificando deploy - Estado incierto', 'production-deploy')
                        error("No se pudo verificar el estado del deploy - Marcando como fallido por seguridad")
                    }
                }
            }
        }
        
        stage('Smoke Tests Post-Deploy') {
            steps {
                script {
                    updateGitHubStatus('pending', 'Ejecutando tests post-deploy...', 'production-deploy')
                    
                    echo "🧪 Ejecutando smoke tests post-deploy..."
                    
                    try {
                        // Ejecutar un test básico para confirmar que el org funciona
                        bat "${SF_CMD} data query --query \"SELECT Id, Name FROM User LIMIT 1\" --target-org %SFDX_ALIAS%"
                        
                        // Si tienes tests específicos post-deploy, añádelos aquí
                        echo "✅ Smoke tests pasaron - Org responde correctamente"
                        env.SMOKE_TESTS_PASSED = "true"
                        
                    } catch (Exception e) {
                        echo "❌ Smoke tests fallaron: ${e.getMessage()}"
                        env.SMOKE_TESTS_PASSED = "false"
                        updateGitHubStatus('failure', 'Smoke tests fallaron - Deploy marcado como fallido', 'production-deploy')
                        error("Smoke tests post-deploy fallaron - Deploy marcado como fallido")
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Limpiar archivos temporales
                bat "if exist auth_url.txt del auth_url.txt"
                echo "🧹 Archivos temporales limpiados"
            }
        }
        success { 
            script {
                // Solo marcar como exitoso si TODAS las verificaciones pasaron
                if (env.DEPLOY_VERIFIED == "true" && env.SMOKE_TESTS_PASSED == "true") {
                    // ✅ ÉXITO COMPLETO - Notificar a GitHub
                    updateGitHubStatus('success', 'Deploy completado exitosamente en producción', 'production-deploy')
                    
                    echo """
╔══════════════════════════════════════════════════════════════╗
║               🎉 DEPLOY A PRODUCCIÓN EXITOSO                 ║
╠══════════════════════════════════════════════════════════════╣
║ Branch: ${env.BRANCH_NAME}                                   ║
║ Commit: ${env.GIT_COMMIT?.take(8)}                           ║
║ Fecha: ${new Date()}                                         ║
║ Tipo de Deploy: ${env.DEPLOY_TYPE}                           ║
║                                                              ║
║ ✅ ESTADO: Código desplegado exitosamente en producción     ║
║ ✅ VERIFICACIÓN: Deploy confirmado como exitoso             ║
║ ✅ SMOKE TESTS: Org funcionando correctamente               ║
║ ✅ GITHUB: Status actualizado como SUCCESS                  ║
║                                                              ║
║ 🌟 Main branch ahora marcada como exitosa en GitHub         ║
╚══════════════════════════════════════════════════════════════╝
"""
                    
                    // Marcar el build como exitoso con descripción
                    currentBuild.description = "🎉 Deploy exitoso y verificado - GitHub actualizado"
                    currentBuild.result = 'SUCCESS'
                    
                } else {
                    echo "❌ Deploy no puede marcarse como exitoso - Verificaciones fallaron"
                    echo "Deploy Verified: ${env.DEPLOY_VERIFIED}"
                    echo "Smoke Tests: ${env.SMOKE_TESTS_PASSED}"
                    
                    updateGitHubStatus('failure', 'Deploy incompleto - Verificaciones fallaron', 'production-deploy')
                    currentBuild.result = 'FAILURE'
                    error("Deploy no puede considerarse exitoso debido a verificaciones fallidas")
                }
            }
        }
        failure { 
            script {
                // ❌ FALLO - Notificar a GitHub
                updateGitHubStatus('failure', 'Deploy falló - Revisar logs de Jenkins', 'production-deploy')
                
                echo """
╔══════════════════════════════════════════════════════════════╗
║                💥 DEPLOY A PRODUCCIÓN FALLÓ                  ║
╠══════════════════════════════════════════════════════════════╣
║ Branch: ${env.BRANCH_NAME}                                   ║
║ Commit: ${env.GIT_COMMIT?.take(8)}                           ║
║ Fecha: ${new Date()}                                         ║
║ Tipo de Deploy: ${env.DEPLOY_TYPE ?: 'No especificado'}      ║
║                                                              ║
║ ❌ ESTADO: Deploy falló - Producción NO afectada             ║
║ ❌ GITHUB: Status marcado como FAILED                        ║
║                                                              ║
║ 🔴 Main branch marcada como fallida hasta resolución         ║
║                                                              ║
║ Ver detalles en Jenkins para más información                 ║
╚══════════════════════════════════════════════════════════════╝
"""
            }
        }
        cleanup {
            script {
                // Limpieza adicional si es necesario
                echo "🧹 Limpieza finalizada"
            }
        }
    }
}

// Función para crear package.xml completo para producción
def createProductionPackage() {
    def packageXml = '''<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
    <types>
        <members>*</members>
        <name>ApexClass</name>
    </types>
    <types>
        <members>*</members>
        <name>CustomObject</name>
    </types>
    <version>59.0</version>
</Package>
'''
    writeFile file: 'package/package.xml', text: packageXml
    echo "✅ package.xml completo generado para producción"
}