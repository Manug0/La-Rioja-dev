pipeline {
    agent any
    environment {
        SFDX_AUTH_URL = credentials('SFDX_AUTH_URL_PRE')
        SFDX_ALIAS = 'pre'
        PACKAGE_DIR = 'force-app'
        SF_DISABLE_TELEMETRY = "true"
        SF_CMD = 'C:\\Users\\Manu\\AppData\\Local\\sf\\client\\2.92.7-df40848\\bin\\sf.cmd'
        
        // Variables para notificaciones
        SLACK_CHANNEL = credentials('SLACK_CHANNEL') // Opcional
        EMAIL_LIST = credentials('EMAIL_LIST') // Lista de emails para notificar
    }
    
    // Solo ejecutar en main branch despu√©s de merge
    when {
        branch 'main'
    }
    
    stages {
        stage('Verificar Prerequisites') {
            steps {
                script {
                    echo "üîç Verificando prerequisites para deploy..."
                    
                    // Verificar que este commit viene de un merge de PR
                    def commitMessage = bat(script: "git log -1 --pretty=format:%%s", returnStdout: true).trim()
                    echo "Commit message: ${commitMessage}"
                    
                    if (commitMessage.contains("Merge pull request")) {
                        echo "‚úÖ Deploy autorizado - Commit proviene de merge de PR"
                        env.DEPLOY_AUTHORIZED = "true"
                    } else {
                        echo "‚ùå Deploy NO autorizado - Commit no proviene de merge de PR"
                        env.DEPLOY_AUTHORIZED = "false"
                        error("Deploy cancelado: Solo se permite deploy desde merge de PR validado")
                    }
                }
            }
        }
        
        stage('Confirmaci√≥n Manual') {
            steps {
                script {
                    // Pausa para confirmaci√≥n manual
                    def userInput
                    try {
                        timeout(time: 10, unit: 'MINUTES') {
                            userInput = input(
                                id: 'DeployConfirmation',
                                message: 'Confirmar deploy a PRODUCCI√ìN',
                                parameters: [
                                    choice(
                                        name: 'DEPLOY_ACTION',
                                        choices: ['CANCELAR', 'DEPLOY_NORMAL', 'DEPLOY_CON_TESTS'],
                                        description: 'Selecciona el tipo de deploy'
                                    )
                                ]
                            )
                        }
                    } catch (err) {
                        echo "‚ùå Timeout o cancelaci√≥n manual del deploy"
                        error("Deploy cancelado por timeout o intervenci√≥n manual")
                    }
                    
                    env.DEPLOY_TYPE = userInput
                    echo "Tipo de deploy seleccionado: ${env.DEPLOY_TYPE}"
                    
                    if (env.DEPLOY_TYPE == 'CANCELAR') {
                        error("Deploy cancelado manualmente")
                    }
                }
            }
        }
        
        stage('Checkout') { 
            steps { 
                checkout scm 
                echo "‚úÖ C√≥digo descargado desde main branch"
            }
        }
        
        stage('Verificar SFDX') { 
            steps { 
                bat "${SF_CMD} --version"
                echo "‚úÖ SFDX CLI verificado"
            }
        }
        
        stage('Authenticate') {
            steps {
                script {
                    echo "üîê Autenticando con org de producci√≥n..."
                    bat 'echo %SFDX_AUTH_URL% > auth_url.txt'
                    bat "${SF_CMD} org login sfdx-url --sfdx-url-file auth_url.txt --alias %SFDX_ALIAS%"
                    echo "‚úÖ Autenticaci√≥n exitosa"
                }
            }
        }
        
        stage('Generar Package Deploy') {
            steps {
                script {
                    echo "üì¶ Generando package para deploy..."
                    
                    // Crear directorio package si no existe
                    bat "if not exist package mkdir package"
                    
                    try {
                        // Intentar obtener los cambios del √∫ltimo merge
                        def lastMergeCommit = bat(script: "git log --merges -1 --pretty=format:%%H", returnStdout: true).trim()
                        def parentCommits = bat(script: "git log --pretty=format:%%P -1 ${lastMergeCommit}", returnStdout: true).trim().split(' ')
                        
                        if (parentCommits.length >= 2) {
                            def fromCommit = parentCommits[0]  // Commit de main antes del merge
                            def toCommit = parentCommits[1]    // √öltimo commit de la rama mergeada
                            
                            echo "Generando delta desde ${fromCommit} hasta ${toCommit}"
                            
                            // Verificar plugin sfdx-git-delta
                            def pluginCheck = bat(script: "${SF_CMD} plugins | findstr sfdx-git-delta", returnStatus: true)
                            
                            if (pluginCheck == 0) {
                                bat "\"${SF_CMD}\" sgd source delta --from \"${fromCommit}\" --to \"${toCommit}\" --output ."
                                echo "‚úÖ Package.xml generado con delta"
                            } else {
                                echo "‚ö†Ô∏è Plugin sfdx-git-delta no encontrado, usando package completo"
                                createProductionPackage()
                            }
                        } else {
                            echo "‚ö†Ô∏è No se pudo determinar el delta, usando package completo"
                            createProductionPackage()
                        }
                        
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Error generando delta: ${e.getMessage()}"
                        echo "Usando package completo como fallback"
                        createProductionPackage()
                    }
                    
                    // Verificar que el package.xml existe
                    if (fileExists('package\\package.xml')) {
                        bat "type package\\package.xml"
                        echo "‚úÖ Package.xml listo para deploy"
                    } else {
                        error("‚ùå Error: package.xml no encontrado")
                    }
                }
            }
        }
        
        stage('Deploy a Producci√≥n') {
            steps {
                script {
                    echo "üöÄ Iniciando deploy a PRODUCCI√ìN..."
                    
                    try {
                        if (env.DEPLOY_TYPE == 'DEPLOY_CON_TESTS') {
                            echo "Deploy con tests completos..."
                            bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --wait 30 --test-level RunLocalTests"
                        } else {
                            echo "Deploy normal (sin tests adicionales)..."
                            bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --wait 30"
                        }
                        
                        echo "‚úÖ Deploy completado exitosamente"
                        
                    } catch (Exception e) {
                        echo "‚ùå Error en deploy: ${e.getMessage()}"
                        throw e
                    }
                }
            }
        }
        
        stage('Verificar Deploy') {
            steps {
                script {
                    echo "üîç Verificando estado del deploy..."
                    
                    try {
                        // Verificar el √∫ltimo deploy
                        bat "${SF_CMD} project deploy report --target-org %SFDX_ALIAS%"
                        echo "‚úÖ Verificaci√≥n completada"
                        
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Error verificando deploy: ${e.getMessage()}"
                        // No fallar el pipeline por esto
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Limpiar archivos temporales
                bat "if exist auth_url.txt del auth_url.txt"
                
                // Log final
                echo "üèÅ Pipeline de deploy completado"
            }
        }
        success { 
            script {
                echo "üéâ ¬°DEPLOY A PRODUCCI√ìN EXITOSO!"
                
                // Notificar √©xito
                def successMessage = """
## üéâ Deploy a Producci√≥n EXITOSO

**Rama:** ${env.BRANCH_NAME}
**Commit:** ${env.GIT_COMMIT}
**Fecha:** ${new Date()}
**Tipo de Deploy:** ${env.DEPLOY_TYPE}

‚úÖ **Estado:** C√≥digo desplegado exitosamente en producci√≥n
üîó **Jenkins:** [Ver log completo](${BUILD_URL}console)

### Pr√≥ximos pasos:
- Verificar funcionalidad en producci√≥n
- Monitorear logs de errores
- Comunicar a usuarios finales si es necesario
"""
                
                // Enviar notificaci√≥n por email
                try {
                    emailext (
                        subject: "‚úÖ Deploy a Producci√≥n EXITOSO - ${env.JOB_NAME}",
                        body: successMessage,
                        to: "${env.EMAIL_LIST}",
                        mimeType: 'text/html'
                    )
                } catch (Exception e) {
                    echo "Error enviando email: ${e.getMessage()}"
                }
                
                echo successMessage
            }
        }
        failure { 
            script {
                echo "üí• DEPLOY A PRODUCCI√ìN FALL√ì"
                
                // Notificar fallo
                def failureMessage = """
## üí• Deploy a Producci√≥n FALL√ì

**Rama:** ${env.BRANCH_NAME}
**Commit:** ${env.GIT_COMMIT}
**Fecha:** ${new Date()}
**Tipo de Deploy:** ${env.DEPLOY_TYPE ?: 'No especificado'}

‚ùå **Estado:** Deploy fall√≥ - Producci√≥n NO afectada
üîó **Jenkins:** [Ver log de errores](${BUILD_URL}console)

### Acciones requeridas:
1. Revisar logs de Jenkins para identificar el error
2. Corregir problemas en c√≥digo
3. Crear nuevo PR con las correcciones
4. Re-ejecutar validaciones
5. Intentar deploy nuevamente

### Contacto:
- Equipo DevOps: [email/slack]
- Documentaci√≥n: [wiki/confluence]
"""
                
                // Enviar notificaci√≥n por email
                try {
                    emailext (
                        subject: "‚ùå Deploy a Producci√≥n FALL√ì - ${env.JOB_NAME}",
                        body: failureMessage,
                        to: "${env.EMAIL_LIST}",
                        mimeType: 'text/html'
                    )
                } catch (Exception e) {
                    echo "Error enviando email: ${e.getMessage()}"
                }
                
                echo failureMessage
            }
        }
        aborted {
            script {
                echo "‚èπÔ∏è Deploy cancelado manualmente"
                
                def abortedMessage = """
## ‚èπÔ∏è Deploy a Producci√≥n CANCELADO

**Motivo:** Cancelado manualmente o por timeout
**Fecha:** ${new Date()}

‚ÑπÔ∏è **Estado:** No se realizaron cambios en producci√≥n
"""
                
                echo abortedMessage
            }
        }
    }
}

// Funci√≥n para crear package.xml de producci√≥n
def createProductionPackage() {
    def packageXml = '''<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
    <types>
        <members>HSU_SistemasUpdater</members>
        <members>HSU_UTSUpdater</members>
        <members>HSU_SistemasUpdater_TEST</members>
        <members>HSU_UTSUpdater_TEST</members>
        <n>ApexClass</n>
    </types>
    <types>
        <members>HSU_GlobalLists__c</members>
        <n>CustomObject</n>
    </types>
    <version>59.0</version>
</Package>'''
    
    writeFile file: 'package/package.xml', text: packageXml
    echo "‚úÖ Package.xml de producci√≥n creado"
}