pipeline {
    agent any
    environment {
        SFDX_AUTH_URL = credentials('SFDX_AUTH_URL_PRE')
        GITHUB_HSU_TAG = 'HSU_START'
        SFDX_ALIAS = 'pre'
        SF_CMD = 'C:\\Users\\Manu\\AppData\\Local\\sf\\client\\2.92.7-df40848\\bin\\sf.cmd'
        GITHUB_TOKEN = credentials('github-pat')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Verificar si el repo est√° shallow antes de hacer unshallow
                    def isShallow = bat(script: "git rev-parse --is-shallow-repository", returnStdout: true).trim()
                    if (isShallow == 'true') {
                        echo "üì• Repositorio shallow detectado, obteniendo historial completo..."
                        bat "git fetch --unshallow"
                    } else {
                        echo "üì• Repositorio ya completo"
                    }
                    
                    // Fetch de tags
                    bat "git fetch --tags --force"
                    
                    updateGitHubStatus('pending', 'Iniciando Deploy...', 'production-deploy')
                    echo "üöÄ Iniciando pipeline de Deploy a Producci√≥n"
                }
            }
        }

        stage('Generar Package con Delta') {
            steps {
                script {
                    echo "üì¶ Generando package.xml con cambios desde ${env.GITHUB_HSU_TAG} a HEAD..."

                    // Verificar que el tag existe
                    def tagExists = bat(script: "git tag -l ${env.GITHUB_HSU_TAG}", returnStdout: true).trim()
                    if (!tagExists) {
                        error "‚ùå Tag ${env.GITHUB_HSU_TAG} no encontrado en el repositorio"
                    }
                    echo "‚úÖ Tag ${env.GITHUB_HSU_TAG} encontrado"

                    // Mostrar cambios para debugging
                    echo "üìã Cambios que se van a desplegar:"
                    bat "git diff --name-only ${env.GITHUB_HSU_TAG}..HEAD"

                    // Autenticaci√≥n
                    echo "üîê Autenticando con Salesforce..."
                    bat 'echo %SFDX_AUTH_URL% > auth_url.txt'
                    bat "${SF_CMD} org login sfdx-url --sfdx-url-file auth_url.txt --alias %SFDX_ALIAS%"
                    echo "‚úÖ Autenticaci√≥n exitosa"
                    
                    // Limpiar y crear carpeta package
                    bat "if exist package rmdir /s /q package"
                    bat "mkdir package"

                    try {
                        // Generar delta con sgd usando nueva sintaxis
                        echo "üîÑ Generando delta con SGD..."
                        bat "\"${SF_CMD}\" sgd source delta --from \"${env.GITHUB_HSU_TAG}\" --to HEAD --output-dir package --generate-delta"
                        echo "‚úÖ Delta generado con SGD"
                    } catch (Exception e) {
                        echo "‚ùå Error con SGD: ${e.getMessage()}"
                        echo "üîß Creando package.xml manual..."
                        createManualPackageXml()
                    }

                    // Verificar package.xml
                    if (fileExists('package\\package.xml')) {
                        echo "üìÑ Contenido de package.xml:"
                        bat "type package\\package.xml"
                        
                        // Verificar que tenga contenido v√°lido
                        def packageContent = readFile('package\\package.xml')
                        if (packageContent.contains('<types>')) {
                            echo "‚úÖ Package.xml v√°lido para deploy"
                            env.HAS_CHANGES = "true"
                        } else {
                            echo "‚ö†Ô∏è Package.xml vac√≠o - no hay cambios para desplegar"
                            env.HAS_CHANGES = "false"
                        }
                    } else {
                        echo "‚ùå No se pudo generar package.xml"
                        env.HAS_CHANGES = "false"
                    }
                }
            }
        }

        stage('Desplegar en Producci√≥n') {
            when {
                environment name: 'HAS_CHANGES', value: 'true'
            }
            steps {
                script {
                    updateGitHubStatus('pending', 'Desplegando en Producci√≥n...', 'production-deploy')
                    echo "üöÄ Iniciando despliegue en Producci√≥n..."

                    try {
                        // Deploy con tests
                        echo "üîÑ Ejecutando deploy con validaci√≥n de tests..."
                        bat "${SF_CMD} project deploy start --manifest package\\package.xml --target-org %SFDX_ALIAS% --test-level RunLocalTests --wait 30"
                        
                        updateGitHubStatus('success', 'Deploy exitoso', 'production-deploy')
                        echo "‚úÖ Deploy completado exitosamente"
                        
                        // Actualizar tag despu√©s del deploy exitoso
                        echo "üè∑Ô∏è Actualizando tag ${env.GITHUB_HSU_TAG} al commit actual..."
                        bat "git tag -d ${env.GITHUB_HSU_TAG}"
                        bat "git tag ${env.GITHUB_HSU_TAG} HEAD"
                        bat "git push origin ${env.GITHUB_HSU_TAG} --force"
                        echo "‚úÖ Tag actualizado exitosamente"
                        
                    } catch (Exception e) {
                        updateGitHubStatus('failure', 'Deploy fall√≥ en Salesforce', 'production-deploy')
                        echo "‚ùå Deploy fall√≥: ${e.getMessage()}"
                        
                        // Intentar obtener m√°s detalles del error
                        echo "üîç Obteniendo detalles del √∫ltimo deploy..."
                        try {
                            bat "${SF_CMD} project deploy report --target-org %SFDX_ALIAS%"
                        } catch (Exception reportError) {
                            echo "‚ö†Ô∏è No se pudo obtener reporte detallado: ${reportError.getMessage()}"
                        }
                        
                        error "Deploy fall√≥"
                    }
                }
            }
        }

        stage('Sin Cambios') {
            when {
                environment name: 'HAS_CHANGES', value: 'false'
            }
            steps {
                script {
                    updateGitHubStatus('success', 'No hay cambios para desplegar', 'production-deploy')
                    echo "‚úÖ Pipeline completado - No hay cambios de metadata para desplegar"
                }
            }
        }
    }

    post {
        always {
            script {
                // Limpieza
                bat "if exist auth_url.txt del auth_url.txt"
                echo "üßπ Limpieza finalizada"
            }
        }
        failure {
            script {
                echo "‚ùå Pipeline fall√≥"
                updateGitHubStatus('failure', 'Pipeline fall√≥', 'production-deploy')
            }
        }
    }
}

def createManualPackageXml() {
    echo "üîß Creando package.xml manual para deploy..."
    
    // Obtener lista de archivos cambiados
    def changedFiles = bat(script: "git diff --name-only ${env.GITHUB_HSU_TAG}..HEAD", returnStdout: true).trim().split('\n')
    
    def packageContent = """<?xml version="1.0" encoding="UTF-8"?>
<Package xmlns="http://soap.sforce.com/2006/04/metadata">
"""
    
    def apexClasses = []
    def triggers = []
    def flows = []
    def customObjects = []
    def customFields = []
    def layouts = []
    def profiles = []
    def permissionSets = []
    def lwcComponents = []
    def auraComponents = []
    
    // Clasificar archivos por tipo
    changedFiles.each { file ->
        if (file.trim()) {
            echo "üîç Analizando archivo: ${file}"
            
            // Apex Classes
            if (file.endsWith('.cls') && file.contains('force-app/main/default/classes/')) {
                def className = file.tokenize('/').last().replace('.cls', '')
                apexClasses.add(className)
                echo "   ‚úÖ Clase Apex: ${className}"
            }
            // Triggers
            else if (file.endsWith('.trigger') && file.contains('force-app/main/default/triggers/')) {
                def triggerName = file.tokenize('/').last().replace('.trigger', '')
                triggers.add(triggerName)
                echo "   ‚úÖ Trigger: ${triggerName}"
            }
            // Flows
            else if (file.endsWith('.flow-meta.xml') && file.contains('force-app/main/default/flows/')) {
                def flowName = file.tokenize('/').last().replace('.flow-meta.xml', '')
                flows.add(flowName)
                echo "   ‚úÖ Flow: ${flowName}"
            }
            // Custom Objects
            else if (file.endsWith('.object-meta.xml') && file.contains('force-app/main/default/objects/')) {
                def objectName = file.tokenize('/').last().replace('.object-meta.xml', '')
                customObjects.add(objectName)
                echo "   ‚úÖ Custom Object: ${objectName}"
            }
            // Custom Fields
            else if (file.endsWith('.field-meta.xml') && file.contains('force-app/main/default/objects/')) {
                def parts = file.split('/')
                def objectName = parts[parts.length - 3] // Nombre del objeto
                def fieldName = parts[parts.length - 1].replace('.field-meta.xml', '')
                customFields.add("${objectName}.${fieldName}")
                echo "   ‚úÖ Custom Field: ${objectName}.${fieldName}"
            }
            // Layouts
            else if (file.endsWith('.layout-meta.xml') && file.contains('force-app/main/default/layouts/')) {
                def layoutName = file.tokenize('/').last().replace('.layout-meta.xml', '')
                layouts.add(layoutName)
                echo "   ‚úÖ Layout: ${layoutName}"
            }
            // Profiles
            else if (file.endsWith('.profile-meta.xml') && file.contains('force-app/main/default/profiles/')) {
                def profileName = file.tokenize('/').last().replace('.profile-meta.xml', '')
                profiles.add(profileName)
                echo "   ‚úÖ Profile: ${profileName}"
            }
            // Permission Sets
            else if (file.endsWith('.permissionset-meta.xml') && file.contains('force-app/main/default/permissionsets/')) {
                def permSetName = file.tokenize('/').last().replace('.permissionset-meta.xml', '')
                permissionSets.add(permSetName)
                echo "   ‚úÖ Permission Set: ${permSetName}"
            }
            // LWC Components
            else if (file.contains('force-app/main/default/lwc/') && file.endsWith('.js')) {
                def lwcName = file.split('/lwc/')[1].split('/')[0]
                if (!lwcComponents.contains(lwcName)) {
                    lwcComponents.add(lwcName)
                    echo "   ‚úÖ LWC Component: ${lwcName}"
                }
            }
            // Aura Components
            else if (file.contains('force-app/main/default/aura/') && file.endsWith('.cmp')) {
                def auraName = file.split('/aura/')[1].split('/')[0]
                if (!auraComponents.contains(auraName)) {
                    auraComponents.add(auraName)
                    echo "   ‚úÖ Aura Component: ${auraName}"
                }
            }
        }
    }
    
    echo "üìä Resumen de componentes para deploy:"
    echo "   - Clases Apex: ${apexClasses.size()}"
    echo "   - Triggers: ${triggers.size()}"
    echo "   - Flows: ${flows.size()}"
    echo "   - Custom Objects: ${customObjects.size()}"
    echo "   - Custom Fields: ${customFields.size()}"
    echo "   - Layouts: ${layouts.size()}"
    echo "   - Profiles: ${profiles.size()}"
    echo "   - Permission Sets: ${permissionSets.size()}"
    echo "   - LWC Components: ${lwcComponents.size()}"
    echo "   - Aura Components: ${auraComponents.size()}"
    
    // Generar XML para cada tipo
    if (apexClasses) {
        packageContent += generatePackageType('ApexClass', apexClasses)
    }
    if (triggers) {
        packageContent += generatePackageType('ApexTrigger', triggers)
    }
    if (flows) {
        packageContent += generatePackageType('Flow', flows)
    }
    if (customObjects) {
        packageContent += generatePackageType('CustomObject', customObjects)
    }
    if (customFields) {
        packageContent += generatePackageType('CustomField', customFields)
    }
    if (layouts) {
        packageContent += generatePackageType('Layout', layouts)
    }
    if (profiles) {
        packageContent += generatePackageType('Profile', profiles)
    }
    if (permissionSets) {
        packageContent += generatePackageType('PermissionSet', permissionSets)
    }
    if (lwcComponents) {
        packageContent += generatePackageType('LightningComponentBundle', lwcComponents)
    }
    if (auraComponents) {
        packageContent += generatePackageType('AuraDefinitionBundle', auraComponents)
    }
    
    packageContent += """    <version>63.0</version>
</Package>"""
    
    // Solo escribir si hay contenido
    def totalComponents = apexClasses.size() + triggers.size() + flows.size() + customObjects.size() + 
                         customFields.size() + layouts.size() + profiles.size() + permissionSets.size() + 
                         lwcComponents.size() + auraComponents.size()
    
    if (totalComponents > 0) {
        writeFile file: 'package\\package.xml', text: packageContent
        echo "‚úÖ Package.xml manual creado con ${totalComponents} componentes"
        echo "üìÑ Contenido del package.xml:"
        echo packageContent
    } else {
        echo "‚ö†Ô∏è No se encontraron componentes de Salesforce para el package.xml"
    }
}

def generatePackageType(metadataType, members) {
    def content = """    <types>
"""
    members.each { member ->
        content += "        <members>${member}</members>\n"
    }
    content += """        <n>${metadataType}</n>
    </types>
"""
    return content
}

def updateGitHubStatus(state, description, context) {
    try {
        def repoUrl = scm.getUserRemoteConfigs()[0].getUrl()
        def repoName = repoUrl.tokenize('/').last().replace('.git', '')
        def repoOwner = repoUrl.tokenize('/')[-2]
        def commitSha = env.GIT_COMMIT
        def targetUrl = "${BUILD_URL}console"

        def payload = [
            state       : state,
            target_url  : targetUrl,
            description : description,
            context     : "jenkins/${context}"
        ]

        def jsonPayload = groovy.json.JsonOutput.toJson(payload)

        withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GH_USER', passwordVariable: 'GH_TOKEN')]) {
            httpRequest(
                acceptType: 'APPLICATION_JSON',
                contentType: 'APPLICATION_JSON',
                httpMode: 'POST',
                requestBody: jsonPayload,
                url: "https://api.github.com/repos/${repoOwner}/${repoName}/statuses/${commitSha}",
                customHeaders: [
                    [name: 'Authorization', value: "token ${GH_TOKEN}"],
                    [name: 'User-Agent', value: 'Jenkins-Pipeline']
                ]
            )
        }

        echo "‚úÖ GitHub status actualizado: ${state} - ${description}"
    } catch (Exception e) {
        echo "‚ö†Ô∏è Error actualizando GitHub status: ${e.getMessage()}"
    }
}